/*
 * Kneron GC2145 sensor driver
 *
 * Copyright (C) 2019 Kneron, Inc. All rights reserved.
 *
 */

#include <stdlib.h>
#include "project.h"
#include "kdev_sensor.h"
#include "kdrv_i2c.h"
#include "kdrv_gpio.h"
#include "kdrv_clock.h"
//#define GC2145_DBG
#ifdef GC2145_DBG
#include "kmdw_console.h"
#define sensor_msg(fmt, ...) kmdw_printf("[%s] " fmt, __func__, ##__VA_ARGS__)
#else
#define sensor_msg(fmt, ...)
#endif

#define ARRAY_SIZE(x)       (sizeof(x) / sizeof((x)[0]))
static const struct sensor_datafmt_info gc2145_colour_fmts[] = {
    { PIX_FMT_YCBCR,    COLORSPACE_YUV },
    { PIX_FMT_RGB565,   COLORSPACE_RGB },
};

static struct sensor_device gc2145_dev = {
    .addr = 0x3C,
};

struct sensor_init_seq gc2145_init_regs[] = {
    //SENSORDB("GC2145MIPI_Sensor_Init");
    // reset : soft_reset, cm_reset, mipi_reset
    {0xfe, 0xf0},
    {0xfe, 0xf0},
    {0xfe, 0xf0},

    //pll / clock
    {0xfc, 0x06}, // vpll_en, vpix_en, analog pwd enable=0
    {0xf6, 0x00}, // up_dn : not pull. PWD : pull down
    {0xf7, 0x1d}, // PLL_mode1 [7]not dvp, serial_clk_double = 1, clk_double=1, div2_en=0, pll_en=1
    {0xf8, 0x84}, // PLL_mode2 [7]pll_dgdiv_en=1, [5:0]divx4 = 4
    {0xfa, 0x00}, // clk_div_mode [7:4]divide_by : 0, [3:0]clock_duty = 0
    {0xf9, 0x8e}, // regf clk enable, isp all clock enable, serial clk enable, re_lock_pll
    {0xf2, 0x00},

    /////////////////////////////////////////////////
    //////////////////ISP reg//////////////////////
    ////////////////////////////////////////////////////
    //reset release
    {0xfe, 0x00},
    //Exposure : 1250
    {0x03, 0x04},
    {0x04, 0xe2},
    //Row Start
    {0x09, 0x00},
    {0x0a, 0x00},
    //Col Start
    {0x0b, 0x00},
    {0x0c, 0x00},
    //Window Height : 1216 , 4c0h
    {0x0d, 0x04},
    {0x0e, 0xc0},
    //Window Width : 1618
    {0x0f, 0x06},
    {0x10, 0x52},

    {0x12, 0x2e},

    {0x17, 0x15}, //bit1: updown or bit0:mirror
    {0x18, 0x22},
    {0x19, 0x0e},
    {0x1a, 0x01},
    {0x1b, 0x4b},
    {0x1c, 0x07},
    {0x1d, 0x10},
    {0x1e, 0x88},
    {0x1f, 0x78},
    {0x20, 0x03},
    {0x21, 0x40},
    {0x22, 0xa0},
    {0x24, 0x16},
    {0x25, 0x01},
    {0x26, 0x10},
    {0x2d, 0x60},
    {0x30, 0x01},
    {0x31, 0x90},
    {0x33, 0x06},
    {0x34, 0x01},
    /////////////////////////////////////////////////
    //////////////////ISP reg////////////////////
    /////////////////////////////////////////////////
    {0xfe, 0x00},
    {0x80, 0x7f},
    {0x81, 0x26},
    {0x82, 0xfa},
    {0x83, 0x00}, //special effect

#if IMGSRC_FORMAT_RGB == IMG_FORMAT_YCBCR
    {0x84, 0x02},
#elif IMGSRC_FORMAT_RGB == IMG_FORMAT_RGB565
    {0x84, 0x06}, // RGB565:6;CbYCrY:0;CrYCbY:1;YCbYcr:2;YCrYcb:3;
#endif

    {0x86, 0x02},
    {0x88, 0x03},
    {0x89, 0x23},
    //{0x89, 0x20}, //eric version
    {0x85, 0x08},
    {0x8a, 0x00},
    {0x8b, 0x00},
    {0xb0, 0x55},
    {0xc3, 0x00},
    {0xc4, 0x80},
    {0xc5, 0x90},
    {0xc6, 0x3b},
    {0xc7, 0x46},
    {0xec, 0x06},
    {0xed, 0x04},
    {0xee, 0x60},
    {0xef, 0x90},
    {0xb6, 0x01},
    {0x90, 0x01},
    {0x91, 0x00},
    {0x92, 0x00},
    {0x93, 0x00},
    {0x94, 0x00},
    {0x95, 0x04},
    {0x96, 0xb0},
    {0x97, 0x06},
    {0x98, 0x40},
    /////////////////////////////////////////
    /////////// BLK ////////////////////////
    /////////////////////////////////////////
    {0xfe, 0x00},
    {0x40, 0x42},
    {0x41, 0x00},
    {0x43, 0x5b},
    {0x5e, 0x00},
    {0x5f, 0x00},
    {0x60, 0x00},
    {0x61, 0x00},
    {0x62, 0x00},
    {0x63, 0x00},
    {0x64, 0x00},
    {0x65, 0x00},
    {0x66, 0x20},
    {0x67, 0x20},
    {0x68, 0x20},
    {0x69, 0x20},
    {0x76, 0x00},
    {0x6a, 0x08},
    {0x6b, 0x08},
    {0x6c, 0x08},
    {0x6d, 0x08},
    {0x6e, 0x08},
    {0x6f, 0x08},
    {0x70, 0x08},
    {0x71, 0x08},
    {0x76, 0x00},
    {0x72, 0xf0},
    {0x7e, 0x3c},
    {0x7f, 0x00},
    {0xfe, 0x02},
    {0x48, 0x15},
    {0x49, 0x00},
    {0x4b, 0x0b},
    {0xfe, 0x00},
    ////////////////////////////////////////
    /////////// AEC ////////////////////////
    ////////////////////////////////////////
    {0xfe, 0x01},
    {0x01, 0x04},
    {0x02, 0xc0},
    {0x03, 0x04},
    {0x04, 0x90},
    {0x05, 0x30},
    {0x06, 0x90},
    {0x07, 0x30},
    {0x08, 0x80},
    {0x09, 0x00},
    {0x0a, 0x82},
    {0x0b, 0x11},
    {0x0c, 0x10},
    {0x11, 0x10},
    {0x13, 0x7b},
    {0x17, 0x00},
    {0x1c, 0x11},
    {0x1e, 0x61},
    {0x1f, 0x35},
    {0x20, 0x40},
    {0x22, 0x40},
    {0x23, 0x20},
    {0xfe, 0x02},
    {0x0f, 0x04},
    {0xfe, 0x01},
    {0x12, 0x35},
    {0x15, 0xb0},
    {0x10, 0x31},
    {0x3e, 0x28},
    {0x3f, 0xb0},
    {0x40, 0x90},
    {0x41, 0x0f},

    /////////////////////////////
    //////// INTPEE /////////////
    /////////////////////////////
    {0xfe, 0x02},
    {0x90, 0x6c},
    {0x91, 0x03},
    {0x92, 0xcb},
    {0x94, 0x33},
    {0x95, 0x84},
    {0x97, 0x65},
    {0xa2, 0x11},
    {0xfe, 0x00},
    /////////////////////////////
    //////// DNDD///////////////
    /////////////////////////////
    {0xfe, 0x02},
    {0x80, 0xc1},
    {0x81, 0x08},
    {0x82, 0x05},
    {0x83, 0x08},
    {0x84, 0x0a},
    {0x86, 0xf0},
    {0x87, 0x50},
    {0x88, 0x15},
    {0x89, 0xb0},
    {0x8a, 0x30},
    {0x8b, 0x10},
    /////////////////////////////////////////
    /////////// ASDE ////////////////////////
    /////////////////////////////////////////
    {0xfe, 0x01},
    {0x21, 0x04},
    {0xfe, 0x02},
    {0xa3, 0x50},
    {0xa4, 0x20},
    {0xa5, 0x40},
    {0xa6, 0x80},
    {0xab, 0x40},
    {0xae, 0x0c},
    {0xb3, 0x46},
    {0xb4, 0x64},
    {0xb6, 0x38},
    {0xb7, 0x01},
    {0xb9, 0x2b},
    {0x3c, 0x04},
    {0x3d, 0x15},
    {0x4b, 0x06},
    {0x4c, 0x20},
    {0xfe, 0x00},
    /////////////////////////////////////////
    /////////// GAMMA   ////////////////////////
    /////////////////////////////////////////

    ///////////////////gamma1////////////////////
    {0xfe, 0x02},
    {0x10, 0x09},
    {0x11, 0x0d},
    {0x12, 0x13},
    {0x13, 0x19},
    {0x14, 0x27},
    {0x15, 0x37},
    {0x16, 0x45},
    {0x17, 0x53},
    {0x18, 0x69},
    {0x19, 0x7d},
    {0x1a, 0x8f},
    {0x1b, 0x9d},
    {0x1c, 0xa9},
    {0x1d, 0xbd},
    {0x1e, 0xcd},
    {0x1f, 0xd9},
    {0x20, 0xe3},
    {0x21, 0xea},
    {0x22, 0xef},
    {0x23, 0xf5},
    {0x24, 0xf9},
    {0x25, 0xff},

    {0xfe, 0x00},
    {0xc6, 0x20},
    {0xc7, 0x2b},
    ///////////////////gamma2////////////////////
    {0xfe, 0x02},
    {0x26, 0x0f},
    {0x27, 0x14},
    {0x28, 0x19},
    {0x29, 0x1e},
    {0x2a, 0x27},
    {0x2b, 0x33},
    {0x2c, 0x3b},
    {0x2d, 0x45},
    {0x2e, 0x59},
    {0x2f, 0x69},
    {0x30, 0x7c},
    {0x31, 0x89},
    {0x32, 0x98},
    {0x33, 0xae},
    {0x34, 0xc0},
    {0x35, 0xcf},
    {0x36, 0xda},
    {0x37, 0xe2},
    {0x38, 0xe9},
    {0x39, 0xf3},
    {0x3a, 0xf9},
    {0x3b, 0xff},
    ///////////////////////////////////////////////
    ///////////YCP ///////////////////////
    ///////////////////////////////////////////////
    {0xfe, 0x02},
    {0xd1, 0x32},
    {0xd2, 0x32},
    {0xd3, 0x40},
    {0xd6, 0xf0},
    {0xd7, 0x10},
    {0xd8, 0xda},
    {0xdd, 0x14},
    {0xde, 0x86},
    {0xed, 0x80},
    {0xee, 0x00},
    {0xef, 0x3f},
    {0xd8, 0xd8},
    ///////////////////abs/////////////////
    {0xfe, 0x01},
    {0x9f, 0x40},
    /////////////////////////////////////////////
    //////////////////////// LSC ///////////////
    //////////////////////////////////////////
    {0xfe, 0x01},
    {0xc2, 0x14},
    {0xc3, 0x0d},
    {0xc4, 0x0c},
    {0xc8, 0x15},
    {0xc9, 0x0d},
    {0xca, 0x0a},
    {0xbc, 0x24},
    {0xbd, 0x10},
    {0xbe, 0x0b},
    {0xb6, 0x25},
    {0xb7, 0x16},
    {0xb8, 0x15},
    {0xc5, 0x00},
    {0xc6, 0x00},
    {0xc7, 0x00},
    {0xcb, 0x00},
    {0xcc, 0x00},
    {0xcd, 0x00},
    {0xbf, 0x07},
    {0xc0, 0x00},
    {0xc1, 0x00},
    {0xb9, 0x00},
    {0xba, 0x00},
    {0xbb, 0x00},
    {0xaa, 0x01},
    {0xab, 0x01},
    {0xac, 0x00},
    {0xad, 0x05},
    {0xae, 0x06},
    {0xaf, 0x0e},
    {0xb0, 0x0b},
    {0xb1, 0x07},
    {0xb2, 0x06},
    {0xb3, 0x17},
    {0xb4, 0x0e},
    {0xb5, 0x0e},
    {0xd0, 0x09},
    {0xd1, 0x00},
    {0xd2, 0x00},
    {0xd6, 0x08},
    {0xd7, 0x00},
    {0xd8, 0x00},
    {0xd9, 0x00},
    {0xda, 0x00},
    {0xdb, 0x00},
    {0xd3, 0x0a},
    {0xd4, 0x00},
    {0xd5, 0x00},
    {0xa4, 0x00},
    {0xa5, 0x00},
    {0xa6, 0x77},
    {0xa7, 0x77},
    {0xa8, 0x77},
    {0xa9, 0x77},
    {0xa1, 0x80},
    {0xa2, 0x80},

    {0xfe, 0x01},
    {0xdf, 0x0d},
    {0xdc, 0x25},
    {0xdd, 0x30},
    {0xe0, 0x77},
    {0xe1, 0x80},
    {0xe2, 0x77},
    {0xe3, 0x90},
    {0xe6, 0x90},
    {0xe7, 0xa0},
    {0xe8, 0x90},
    {0xe9, 0xa0},
    {0xfe, 0x00},
    ///////////////////////////////////////////////
    /////////// AWB////////////////////////
    ///////////////////////////////////////////////
    {0xfe, 0x01},
    {0x4f, 0x00},
    {0x4f, 0x00},
    {0x4b, 0x01},
    {0x4f, 0x00},

    {0x4c, 0x01}, // D75
    {0x4d, 0x71},
    {0x4e, 0x01},
    {0x4c, 0x01},
    {0x4d, 0x91},
    {0x4e, 0x01},
    {0x4c, 0x01},
    {0x4d, 0x70},
    {0x4e, 0x01},

    {0x4c, 0x01}, // D65
    {0x4d, 0x90},
    {0x4e, 0x02},


    {0x4c, 0x01},
    {0x4d, 0xb0},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0x8f},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0x6f},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0xaf},
    {0x4e, 0x02},

    {0x4c, 0x01},
    {0x4d, 0xd0},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0xf0},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0xcf},
    {0x4e, 0x02},
    {0x4c, 0x01},
    {0x4d, 0xef},
    {0x4e, 0x02},

    {0x4c, 0x01},//D50
    {0x4d, 0x6e},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x8e},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xae},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xce},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x4d},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x6d},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x8d},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xad},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xcd},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x4c},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x6c},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x8c},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xac},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xcc},
    {0x4e, 0x03},

    {0x4c, 0x01},
    {0x4d, 0xcb},
    {0x4e, 0x03},

    {0x4c, 0x01},
    {0x4d, 0x4b},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x6b},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0x8b},
    {0x4e, 0x03},
    {0x4c, 0x01},
    {0x4d, 0xab},
    {0x4e, 0x03},

    {0x4c, 0x01},//CWF
    {0x4d, 0x8a},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0xaa},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0xca},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0xca},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0xc9},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0x8a},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0x89},
    {0x4e, 0x04},
    {0x4c, 0x01},
    {0x4d, 0xa9},
    {0x4e, 0x04},

    {0x4c, 0x02},//tl84
    {0x4d, 0x0b},
    {0x4e, 0x05},
    {0x4c, 0x02},
    {0x4d, 0x0a},
    {0x4e, 0x05},

    {0x4c, 0x01},
    {0x4d, 0xeb},
    {0x4e, 0x05},

    {0x4c, 0x01},
    {0x4d, 0xea},
    {0x4e, 0x05},

    {0x4c, 0x02},
    {0x4d, 0x09},
    {0x4e, 0x05},
    {0x4c, 0x02},
    {0x4d, 0x29},
    {0x4e, 0x05},

    {0x4c, 0x02},
    {0x4d, 0x2a},
    {0x4e, 0x05},

    {0x4c, 0x02},
    {0x4d, 0x4a},
    {0x4e, 0x05},

    {0x4c, 0x02},
    {0x4d, 0x8a},
    {0x4e, 0x06},

    {0x4c, 0x02},
    {0x4d, 0x49},
    {0x4e, 0x06},
    {0x4c, 0x02},
    {0x4d, 0x69},
    {0x4e, 0x06},
    {0x4c, 0x02},
    {0x4d, 0x89},
    {0x4e, 0x06},
    {0x4c, 0x02},
    {0x4d, 0xa9},
    {0x4e, 0x06},

    {0x4c, 0x02},
    {0x4d, 0x48},
    {0x4e, 0x06},
    {0x4c, 0x02},
    {0x4d, 0x68},
    {0x4e, 0x06},
    {0x4c, 0x02},
    {0x4d, 0x69},
    {0x4e, 0x06},

    {0x4c, 0x02},//H
    {0x4d, 0xca},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xc9},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xe9},
    {0x4e, 0x07},
    {0x4c, 0x03},
    {0x4d, 0x09},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xc8},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xe8},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xa7},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xc7},
    {0x4e, 0x07},
    {0x4c, 0x02},
    {0x4d, 0xe7},
    {0x4e, 0x07},
    {0x4c, 0x03},
    {0x4d, 0x07},
    {0x4e, 0x07},

    {0x4f, 0x01},
    {0x50, 0x80},
    {0x51, 0xa8},
    {0x52, 0x47},
    {0x53, 0x38},
    {0x54, 0xc7},
    {0x56, 0x0e},
    {0x58, 0x08},
    {0x5b, 0x00},
    {0x5c, 0x74},
    {0x5d, 0x8b},
    {0x61, 0xdb},
    {0x62, 0xb8},
    {0x63, 0x86},
    {0x64, 0xc0},
    {0x65, 0x04},

    {0x67, 0xa8},
    {0x68, 0xb0},
    {0x69, 0x00},
    {0x6a, 0xa8},
    {0x6b, 0xb0},
    {0x6c, 0xaf},
    {0x6d, 0x8b},
    {0x6e, 0x50},
    {0x6f, 0x18},
    {0x73, 0xf0},
    {0x70, 0x0d},
    {0x71, 0x60},
    {0x72, 0x80},
    {0x74, 0x01},
    {0x75, 0x01},
    {0x7f, 0x0c},
    {0x76, 0x70},
    {0x77, 0x58},
    {0x78, 0xa0},
    {0x79, 0x5e},
    {0x7a, 0x54},
    {0x7b, 0x58},
    {0xfe, 0x00},
    //////////////////////////////////////////
    ///////////CC////////////////////////
    //////////////////////////////////////////
    {0xfe, 0x02},
    {0xc0, 0x01},
    {0xc1, 0x44},
    {0xc2, 0xfd},
    {0xc3, 0x04},
    {0xc4, 0xf0},
    {0xc5, 0x48},
    {0xc6, 0xfd},
    {0xc7, 0x46},
    {0xc8, 0xfd},
    {0xc9, 0x02},
    {0xca, 0xe0},
    {0xcb, 0x45},
    {0xcc, 0xec},
    {0xcd, 0x48},
    {0xce, 0xf0},
    {0xcf, 0xf0},
    {0xe3, 0x0c},
    {0xe4, 0x4b},
    {0xe5, 0xe0},
    //////////////////////////////////////////
    ///////////    ABS    ////////////////////
    //////////////////////////////////////////
    {0xfe, 0x01},
    {0x9f, 0x40},
    {0xfe, 0x00},
    //////////////////////////////////////
    ///////////  OUTPUT   ////////////////
    //////////////////////////////////////
    {0xfe, 0x00},
    {0xf2, 0x00},

    //////////////frame rate 50Hz/////////
    {0xfe, 0x00},
    {0x05, 0x01},
    {0x06, 0x56},
    {0x07, 0x00},
    {0x08, 0x32},
    {0xfe, 0x01},
    {0x25, 0x00},
    {0x26, 0xfa},
    {0x27, 0x04},
    {0x28, 0xe2}, //20fps
    {0x29, 0x06},
    {0x2a, 0xd6}, //14fps
    {0x2b, 0x07},
    {0x2c, 0xd0}, //12fps
    {0x2d, 0x0b},
    {0x2e, 0xb8}, //8fps
    {0xfe, 0x00},

    ///////////////dark sun////////////////////
    {0xfe, 0x02},
    {0x40, 0xbf},
    {0x46, 0xcf},
    {0xfe, 0x00},
    /////////////////////////////////////////////////////
    //////////////////////  MIPI    /////////////////////
    /////////////////////////////////////////////////////
    {0xfe, 0x03}, // P3
    {0x02, 0x22},
    {0x03, 0x10}, // 0x12 20140821
    {0x04, 0x10}, // 0x01
    {0x05, 0x00},
    {0x06, 0x88},

#if MIPI_LANE_RGB == 2
    {0x01, 0x87}, // clk lane_p2s_sel, phy_lane1_en, phy_lane0_en, phy_clk_en
    {0x10, 0x95}, // lane_enable, MIPI_enable, RAW8, double_lane
#else
    {0x01, 0x83}, // clk lane_p2s_sel,               phy_lane0_en, phy_clk_en
    {0x10, 0x94}, // lane_enable, MIPI_enable, RAW8
#endif

#if IMGSRC_FORMAT_RGB == IMG_FORMAT_YCBCR
    {0x11, 0x1e},
#elif IMGSRC_FORMAT_RGB == IMG_FORMAT_RGB565
    {0x11, 0x22},
#endif

    {0x12, 0x80},
    {0x13, 0x0c},
    {0x15, 0x10},
    {0x17, 0xf0},

    {0x21, 0x10},
    {0x22, 0x04},
    {0x23, 0x10},
    {0x24, 0x10},
    {0x25, 0x10},
    {0x26, 0x05},
    {0x29, 0x03},
    {0x2a, 0x0a},
    {0x2b, 0x06},

    {0xfe, 0x00}, // P0
    //SENSORDB("GC2145MIPI_Sensor_SVGA");

    {0xfe, 0x00}, // P0
    {0xfd, 0x01}, // column scalar mode
    {0xfa, 0x00},
    //// crop window
    {0xfe, 0x00},
    {0x90, 0x01},
    //out_win_y1
    {0x91, 0x00},
    {0x92, 0x00},
    //out_win_x1
    {0x93, 0x00},
    {0x94, 0x00},

#if SENSOR_RES_RGB == SENSOR_RES_640_480
    // 640X480
    // Out window height
    {0x95, 0x01},
    {0x96, 0xe0},
    // Out window width
    {0x97, 0x02},
    {0x98, 0x80},
#elif SENSOR_RES_RGB == SENSOR_RES_480_272
    // 480x272
    // Out window height
    {0x95, 0x01},
    {0x96, 0x10},
    // Out window width
    {0x97, 0x01},
    {0x98, 0xe0},
#endif

    {0x99, 0x11},
    {0x9a, 0x06},
    //// AWB
    {0xfe, 0x00},
    {0xec, 0x02},
    {0xed, 0x02},
    {0xee, 0x30},
    {0xef, 0x48},
#ifdef MIPI_EXAMPLE
    {0x8c, 0x01},   // test pattern
#endif
    {0xfe, 0x02},
    {0x9d, 0x08},
    {0xfe, 0x01},
    {0x74, 0x00},
    //// AEC
    {0xfe, 0x01},
    {0x01, 0x04},
    {0x02, 0x60},
    {0x03, 0x02},
    {0x04, 0x48},
    {0x05, 0x18},
    {0x06, 0x50},
    {0x07, 0x10},
    {0x08, 0x38},
    {0x0a, 0x80},
    {0x21, 0x04},
    {0xfe, 0x00},
    {0x20, 0x03},
    //// mipi
    {0xfe, 0x03}, //P3, CSI/PHY1.0

#if SENSOR_RES_RGB == SENSOR_RES_640_480
    {0x12, 0x00}, // LWC_set
    {0x13, 0x05},
#elif SENSOR_RES_RGB == SENSOR_RES_480_272
    {0x12, 0xc0}, // LWC_set
    {0x13, 0x03},
#endif

    //FIFO full level
#if MIPI_LANE_RGB == 2
    //400
    {0x04, 0x90},
    {0x05, 0x01},
#elif MIPI_LANE_RGB == 1
    // 1
    {0x04, 0x01},
    {0x05, 0x00},
#endif

    {0xfe, 0x00},

    {0x00, 0x00},
};
static uint32_t kdev_sensor_get_dev_id(void);
static void rgb_set_aec_roi(struct cam_sensor_aec *aec_p)
{
    uint16_t dev_addr = gc2145_dev.addr;
    kdrv_i2c_ctrl_t i2c_port = (kdrv_i2c_ctrl_t)gc2145_dev.i2c_port;

    //set to page 1
    uint16_t reg = 0xfe;
    uint16_t data = 0x01;
    kdrv_i2c_write_register(i2c_port, dev_addr, reg, 1, 1, &data);

    //set roi
    //kdrv_i2c_write_register(kdrv_i2c_ctrl_t ctrl_id, uint16_t slave_addr, uint16_t reg, uint16_t reg_size, uint16_t len, uint8_t * data)
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x01, 1, 1, &aec_p->x1);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x02, 1, 1, &aec_p->x2);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x03, 1, 1, &aec_p->y1);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x04, 1, 1, &aec_p->y2);

    //set center roi
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x05, 1, 1, &aec_p->center_x1);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x06, 1, 1, &aec_p->center_x2);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x07, 1, 1, &aec_p->center_y1);
    kdrv_i2c_write_register(i2c_port, dev_addr, 0x08, 1, 1, &aec_p->center_y2);
}

static void rgb_get_lux(uint16_t* exposure, uint8_t* pre_gain, uint8_t* post_gain, uint8_t* global_gain, uint8_t* y_average)
{
    uint16_t dev_addr = gc2145_dev.addr;
    kdrv_i2c_ctrl_t i2c_port = (kdrv_i2c_ctrl_t)gc2145_dev.i2c_port;

    //set to page 0
    uint16_t data = 0x00;
    kdrv_i2c_write_register(i2c_port, dev_addr, 0xfe, 1, 1, &data);

    //get exposure
    *exposure = 0;
    kdrv_i2c_read_register(i2c_port, dev_addr, 0x03, 1, 1, &data);
    *exposure |= (data << 8);
    kdrv_i2c_read_register(i2c_port, dev_addr, 0x04, 1, 1, &data);
    *exposure |= data;

    //get gain
    kdrv_i2c_read_register(i2c_port, dev_addr, 0xb1, 1, 1, &data);
    *pre_gain = data;
    kdrv_i2c_read_register(i2c_port, dev_addr, 0xb2, 1, 1, &data);
    *post_gain = data;

    // global gain
    kdrv_i2c_read_register(i2c_port, dev_addr, 0xb0, 1, 1, &data);
    *global_gain = data;

    //set to page 1
    data = 0x01;
    kdrv_i2c_write_register(i2c_port, dev_addr, 0xfe, 1, 1, &data);

    // y average
    kdrv_i2c_read_register(i2c_port, dev_addr, 0x14, 1, 1, &data);
    *y_average = data;

    return;
}

static uint32_t gc2145_write_reg(struct sensor_device *sensor_dev, uint16_t reg, uint16_t data)
{
    uint32_t ret;

    ret = kdrv_i2c_write_register((kdrv_i2c_ctrl_t)sensor_dev->i2c_port, sensor_dev->addr, reg, 1, 1, &data);
    return ret;
}

static uint32_t gc2145_read_reg(struct sensor_device *sensor_dev, uint16_t reg, uint16_t *data)
{
    uint32_t ret;

    ret = kdrv_i2c_read_register((kdrv_i2c_ctrl_t)sensor_dev->i2c_port, sensor_dev->addr, reg, 1, 1, data);
    return ret;
}

uint32_t gc2145_init(struct sensor_device *sensor_dev, struct sensor_init_seq *seq)
{
    struct sensor_device *dev = sensor_dev;
    struct sensor_init_seq *init_fnc_ptr;

    for (init_fnc_ptr = seq; ; ++init_fnc_ptr)
    {
        if(init_fnc_ptr->addr == 0 && init_fnc_ptr->value == 0)
            break;
        //sensor_msg("addr =\t%.4x, data = =\t%.4x\n", init_fnc_ptr->addr, (init_fnc_ptr->value & 0xFF));
        gc2145_write_reg(dev, init_fnc_ptr->addr , (uint8_t)(init_fnc_ptr->value & 0xFF));
    }

    uint32_t data = kdev_sensor_get_dev_id();
    sensor_msg("gc2145_init sensor id=%x\n", data);
    return 0;
}

static uint32_t gc2145_set_params(struct sensor_device *sensor_dev)
{
    sensor_msg("   <%s>\n", __func__);
    /* initialize the sensor with default settings */
    return 0;
}

static kdev_status_t kdev_sensor_init(void)
{
    sensor_msg("   <%s>\n", __func__);
    gc2145_init(&gc2145_dev, gc2145_init_regs);

#if (defined(IMGSRC_0_SUPPORT_LED) && IMGSRC_0_SUPPORT_LED == YES)
    for(uint32_t i = 1; i<=IMGSRC_0_LED_STRENGTH;i++)
    {
        kdrv_delay_us(LED_DELAY_INTERVAL);
        kdrv_gpio_write_pin(RGB_LED, true);
        kdrv_delay_us(LED_DELAY_INTERVAL);
        kdrv_gpio_write_pin(RGB_LED, false);
    }
    kdrv_delay_us(LED_DELAY_INTERVAL);
    kdrv_gpio_write_pin(RGB_LED, true);
#endif
    return KDEV_STATUS_OK;
}
static kdev_status_t kdev_sensor_power(uint32_t on)
{
    sensor_msg("   <%s>\n", __func__);

    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_reset()
{
    sensor_msg("   <%s>\n", __func__);

    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_stream(uint32_t enable)
{
    uint16_t readval = 0;
    uint16_t val = 0;

    sensor_msg("   <%s>\n", __func__);
    val = (enable)? 0x95: 0x05;
    gc2145_write_reg(&gc2145_dev, (uint16_t)0xfe , (uint16_t) 0x03);
    if(enable == 1)
    {
        gc2145_write_reg(&gc2145_dev, (uint16_t)0x10 , (uint16_t) val);
    }
    else
    {
        gc2145_write_reg(&gc2145_dev, (uint16_t)0x10 , (uint16_t) val);
    }

    while(readval != val)
    {
        gc2145_read_reg(&gc2145_dev, (uint16_t)0x10, &readval);
    }
    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_enum_fmt(uint32_t index, uint32_t *code)
{
    if (index >= ARRAY_SIZE(gc2145_colour_fmts))
        return KDEV_STATUS_ERROR;

    sensor_msg("   <%s>\n", __func__);
    *code = gc2145_colour_fmts[index].fourcc;
    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_get_fmt(cam_format *format)
{
    sensor_msg("   <%s>\n", __func__);

    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_set_fmt(cam_format *fmt)
{
    sensor_msg("   <%s>\n", __func__);

    return (kdev_status_t)gc2145_set_params(&gc2145_dev);
}

static kdev_status_t kdev_sensor_set_aec(struct cam_sensor_aec *aec_p)
{
    sensor_msg("   <%s>\n", __func__);

    rgb_set_aec_roi(aec_p);

    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_get_lux(uint16_t *expo, uint8_t *pre_gain, uint8_t *post_gain, uint8_t* global_gain, uint8_t* y_average)
{
    sensor_msg("   <%s>\n", __func__);

    rgb_get_lux(expo, pre_gain, post_gain, global_gain, y_average);

    return KDEV_STATUS_OK;
}

static uint32_t kdev_sensor_get_dev_id(void)
{
    uint16_t data = 0;
    uint16_t id = 0;

    gc2145_read_reg(&gc2145_dev, 0xf0, &data);
    id = data<<8;
    gc2145_read_reg(&gc2145_dev, 0xf1, &data);
    id += data;

    return (uint32_t)id;
}
static kdev_status_t kdev_sensor_set_inc_pattern_mode(uint8_t en)
{
    uint16_t nData = 0;
    uint16_t nData2 = 0;

    gc2145_read_reg(&gc2145_dev, 0x8c, &nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x8c, nData, (nData&BIT0));
    nData &= ~BIT0;

    if ( en == 1 )
    {
        nData |= BIT0;
    }

    gc2145_write_reg(&gc2145_dev, 0x8c, nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x8c, nData, (nData&BIT0));
    nData2 = nData;
    nData = 0xff;
    while(nData != nData2)
    {
        gc2145_read_reg(&gc2145_dev, 0x8c, &nData);
        kdrv_delay_us(5);
    }
    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_set_mirror(uint32_t en)
{
    uint16_t nData = 0;
    uint16_t nData2 = 0;

    gc2145_read_reg(&gc2145_dev, 0x17, &nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x17, nData, (nData&BIT0));
    nData &= ~BIT0;

    if ( en == 1 )
    {
        nData |= BIT0;
    }

    gc2145_write_reg(&gc2145_dev, 0x17, nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x17, nData, (nData&BIT0));
    nData2 = nData;
    nData = 0xff;
    while(nData != nData2)
    {
        gc2145_read_reg(&gc2145_dev, 0x17, &nData);
        kdrv_delay_us(5);
    }
    return KDEV_STATUS_OK;
}

static kdev_status_t kdev_sensor_set_flip(uint32_t en)
{
    uint16_t nData = 0;
    uint16_t nData2 = 0;

    gc2145_read_reg(&gc2145_dev, 0x17, &nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x17, nData, (nData&BIT1));
    nData &= ~BIT1;

    if ( en == 1 )
    {
        nData |= BIT1;
    }

    gc2145_write_reg(&gc2145_dev, 0x17, nData);
    sensor_msg("----------%s 0x%x: 0x%X, Switch State: %d\r\n", __func__, 0x17, nData, (nData&BIT1));
    nData2 = nData;
    nData = 0xff;
    while(nData != nData2)
    {
        gc2145_read_reg(&gc2145_dev, 0x17, &nData);
        kdrv_delay_us(5);
    }
    return KDEV_STATUS_OK;
}
static kdev_status_t kdev_sensor_set_devaddress(uint32_t address, uint32_t port_id)
{
    gc2145_dev.addr = address;
    gc2145_dev.i2c_port = port_id;
    return KDEV_STATUS_OK;
}

static sensor_ops gc2145_ops = {
    .s_power        = kdev_sensor_power,
    .reset          = kdev_sensor_reset,
    .s_stream       = kdev_sensor_stream,
    .enum_fmt       = kdev_sensor_enum_fmt,
    .get_fmt        = kdev_sensor_get_fmt,
    .set_fmt        = kdev_sensor_set_fmt,
    .set_gain       = NULL,
    .set_aec        = kdev_sensor_set_aec,
    .set_exp_time   = NULL,
    .get_lux        = kdev_sensor_get_lux,
    .led_switch     = NULL,
    .set_mirror     = kdev_sensor_set_mirror,
    .set_flip       = kdev_sensor_set_flip,
    .get_dev_id     = kdev_sensor_get_dev_id,
    .set_addr       = kdev_sensor_set_devaddress,
    .set_inc        = kdev_sensor_set_inc_pattern_mode,
    .init           = kdev_sensor_init,
};

#if (IMGSRC_0_SENSORID == SENSOR_ID_GC2145)
KDEV_CAM_SENSOR_DRIVER_REGISTER(cam_sensor, 0, &gc2145_ops);
#endif
#if (IMGSRC_1_SENSORID == SENSOR_ID_GC2145)
KDEV_CAM_SENSOR_DRIVER_REGISTER(cam_sensor, 1, &gc2145_ops);
#endif

